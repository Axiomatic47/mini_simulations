# Multi-Civilization Dashboard Documentation

This document provides comprehensive documentation for the multi-civilization dashboard component of the Axiomatic Intelligence Growth Simulation Framework. It covers architecture, deployment, customization, and extension strategies.

## Table of Contents

1. [Overview](#overview)
2. [Architecture](#architecture)
3. [Installation & Setup](#installation--setup)
4. [Usage Guide](#usage-guide)
5. [API Reference](#api-reference)
6. [Development Guide](#development-guide)
7. [Production Deployment](#production-deployment)
8. [Extending the Dashboard](#extending-the-dashboard)
9. [Troubleshooting](#troubleshooting)

## Overview

The Multi-Civilization Dashboard provides interactive visualization capabilities for exploring simulation data from the Axiomatic Intelligence Growth Simulation Framework. It enables researchers and analysts to:

- Track civilization dynamics over time
- Analyze knowledge and suppression patterns
- Monitor key events (collisions, mergers, collapses)
- Assess simulation stability metrics
- Explore correlations between different variables

The dashboard is designed to work with CSV output data from multi-civilization simulations, providing real-time visual analysis capabilities.

## Architecture

The dashboard follows a client-server architecture:

### Backend (Flask)

- **Data Handling**: Reads CSV simulation data and serves it via REST API endpoints
- **Server**: Provides HTTP endpoints for the frontend to consume
- **Data Processing**: Performs any necessary transformations on raw simulation data

### Frontend (HTML/JavaScript)

- **Visualization**: Chart.js for interactive data visualization components
- **UI Framework**: Bootstrap for responsive layout and components
- **Interactivity**: JavaScript for user interaction and dynamic updates
- **Data Fetching**: Fetch API for retrieving data from backend endpoints

### Data Flow

1. CSV simulation data is generated by simulation runs
2. Flask backend reads and processes CSV files
3. Frontend requests data via API endpoints
4. Data is transformed into visualization formats
5. Chart.js renders interactive visualizations
6. User interactions trigger data updates and view changes

## Installation & Setup

### Prerequisites

- Python 3.7+
- Flask
- NumPy
- Pandas
- Modern web browser with JavaScript enabled

### Basic Setup

1. **Install Required Packages**:
   ```bash
   pip install flask pandas numpy
   ```

2. **Run the Dashboard**:
   ```bash
   python minimal_dashboard.py
   ```

3. **Access the Dashboard**:
   Open your browser and navigate to http://127.0.0.1:5000

### Configuration Options

The `minimal_dashboard.py` script supports several configuration options:

```bash
# Run on a different port
python minimal_dashboard.py --port 8080

# Specify a custom data directory
python minimal_dashboard.py --data-dir /path/to/simulation/data

# Run in debug mode
python minimal_dashboard.py --debug
```

## Usage Guide

### Navigation

The dashboard is organized into tabs:

1. **Overview**: High-level summary of simulation metrics
2. **Civilizations**: Detailed view of civilization dynamics
3. **Events**: Tracking of key events like mergers and collapses
4. **Stability**: Monitoring simulation stability metrics

### Time Navigation

- **Time Slider**: Drag to navigate through simulation timesteps
- **Current Stats Panel**: Shows stats for the selected time point
- **Timeline Charts**: Display trends across all timesteps

### Visualization Controls

- **Chart Legends**: Toggle series visibility
- **Chart Tooltips**: Hover for detailed data points
- **Time Line Indicator**: Shows current time position on all charts

### Data Views

- **Line Charts**: For time series data like knowledge and suppression
- **Bar Charts**: For categorical data like event types
- **Pie Charts**: For distribution analysis
- **Tables**: For event logs and detailed metrics

## API Reference

The dashboard exposes the following REST API endpoints:

### GET /api/data/multi_civilization_statistics.csv

Returns simulation statistics data.

**Response**:
```json
[
  {
    "Time": 0,
    "Civilization_Count": 5,
    "knowledge_mean": 1.2,
    "knowledge_max": 2.3,
    "knowledge_min": 0.5,
    "suppression_mean": 7.0,
    "suppression_max": 10.3,
    "suppression_min": 5.2,
    "intelligence_mean": 0.5,
    "truth_mean": 0.1,
    "resources_total": 250,
    "Stability_Issues": 0,
    "Timestep": 1.0
  },
  // Additional timesteps...
]
```

### GET /api/data/multi_civilization_events.csv

Returns event data from the simulation.

**Response**:
```json
[
  {
    "id": 0,
    "type": "merger",
    "time": 25,
    "civ_id1": 2,
    "civ_id2": 5,
    "position_x": 3.4,
    "position_y": 7.2,
    "description": "merger event at time 25"
  },
  // Additional events...
]
```

### GET /api/data/multi_civilization_stability.csv

Returns stability metrics from the simulation.

**Response**:
```json
{
  "Total_Stability_Issues": 87,
  "Circuit_Breaker_Triggers": 52,
  "Max_Knowledge": 48.7,
  "Max_Suppression": 15.3,
  "Max_Intelligence": 42.1,
  "Max_Truth": 37.9,
  "Total_Collisions": 12,
  "Total_Mergers": 8,
  "Total_Collapses": 6,
  "Total_Spawns": 15,
  "Total_New_Civilizations": 9,
  "Used_Dimensional_Analysis": true
}
```

## Development Guide

### Code Organization

For more substantial development, organize the dashboard code as follows:

```
dashboard/
├── app/
│   ├── __init__.py           # App initialization
│   ├── routes.py             # API routes
│   ├── data_handler.py       # Data processing logic
│   ├── static/
│   │   ├── js/
│   │   │   ├── dashboard.js  # Main dashboard logic
│   │   │   ├── charts.js     # Chart configurations
│   │   │   └── utils.js      # Utility functions
│   │   ├── css/
│   │   │   └── styles.css    # Custom styles
│   │   └── img/              # Image assets
│   └── templates/
│       └── index.html        # Main dashboard template
├── config.py                 # Configuration
└── run.py                    # Entry point
```

### Adding New Visualizations

To add a new chart:

1. **Add HTML element**:
   ```html
   <div class="card">
       <div class="card-body">
           <h5 class="card-title">New Visualization</h5>
           <div class="chart-container">
               <canvas id="new-chart"></canvas>
           </div>
       </div>
   </div>
   ```

2. **Create chart in JavaScript**:
   ```javascript
   // In charts.js
   function createNewChart(data) {
       return new Chart(
           document.getElementById('new-chart'),
           {
               type: 'line',
               data: {
                   labels: data.map(d => d.Time),
                   datasets: [{
                       label: 'New Metric',
                       data: data.map(d => d.new_metric),
                       borderColor: '#ff7700',
                       tension: 0.1
                   }]
               },
               options: {
                   responsive: true,
                   maintainAspectRatio: false
               }
           }
       );
   }
   
   // In dashboard.js
   charts.newChart = createNewChart(simulationData);
   ```

3. **Update chart on time changes**:
   ```javascript
   function updateCharts() {
       // Other chart updates...
       
       // Update new chart
       // (if needed - static charts may not need updates)
   }
   ```

### Adding New Data Endpoints

To add a new data endpoint:

1. **Add route to Flask app**:
   ```python
   @app.route('/api/data/new_metric')
   def get_new_metric():
       try:
           # Load and process data
           data = process_new_metric_data()
           return jsonify(data)
       except Exception as e:
           print(f"Error serving new metric data: {e}")
           return jsonify({"error": str(e)}), 500
   ```

2. **Create data processing function**:
   ```python
   def process_new_metric_data():
       # Read data from file or calculate from existing data
       df = pd.read_csv(data_dir / "multi_civilization_statistics.csv")
       
       # Process data
       result = df.apply(lambda row: my_calculation(row), axis=1).to_dict()
       
       return result
   ```

3. **Fetch data in frontend**:
   ```javascript
   async function loadNewMetricData() {
       try {
           const response = await fetch('/api/data/new_metric');
           if (!response.ok) {
               throw new Error(`Failed to fetch: ${response.status}`);
           }
           return await response.json();
       } catch (error) {
           console.error('Error loading new metric data:', error);
           return null;
       }
   }
   ```

## Production Deployment

### WSGI Server Setup

For production, use a WSGI server instead of Flask's built-in server:

1. **Install Gunicorn** (Linux/Mac):
   ```bash
   pip install gunicorn
   ```

   Or **Waitress** (Windows):
   ```bash
   pip install waitress
   ```

2. **Create a WSGI file** (`wsgi.py`):
   ```python
   from dashboard.app import app
   
   if __name__ == "__main__":
       app.run()
   ```

3. **Run with Gunicorn**:
   ```bash
   gunicorn -w 4 -b 0.0.0.0:8000 wsgi:app
   ```

   Or **Waitress**:
   ```bash
   waitress-serve --port=8000 wsgi:app
   ```

### Nginx Configuration

For a production deployment behind Nginx:

```nginx
server {
    listen 80;
    server_name dashboard.yourdomain.com;

    location / {
        proxy_pass http://127.0.0.1:8000;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }

    location /static {
        alias /path/to/dashboard/app/static;
        expires 30d;
    }
}
```

### Docker Deployment

For containerized deployment:

1. **Create a Dockerfile**:
   ```dockerfile
   FROM python:3.9-slim
   
   WORKDIR /app
   
   COPY requirements.txt .
   RUN pip install --no-cache-dir -r requirements.txt
   
   COPY . .
   
   EXPOSE 8000
   
   CMD ["gunicorn", "-w", "4", "-b", "0.0.0.0:8000", "wsgi:app"]
   ```

2. **Create requirements.txt**:
   ```
   flask
   gunicorn
   pandas
   numpy
   ```

3. **Build and run the container**:
   ```bash
   docker build -t civilization-dashboard .
   docker run -p 8000:8000 civilization-dashboard
   ```

## Extending the Dashboard

### Data Persistence with Databases

To store simulation results in a database:

1. **SQLite Integration** (for simplicity):
   ```python
   import sqlite3
   
   def init_db():
       conn = sqlite3.connect('simulations.db')
       cursor = conn.cursor()
       cursor.execute('''
       CREATE TABLE IF NOT EXISTS simulation_runs (
           id INTEGER PRIMARY KEY,
           timestamp TEXT,
           name TEXT,
           parameters TEXT
       )
       ''')
       conn.commit()
       conn.close()
   
   def save_simulation(name, parameters):
       conn = sqlite3.connect('simulations.db')
       cursor = conn.cursor()
       cursor.execute(
           'INSERT INTO simulation_runs (timestamp, name, parameters) VALUES (?, ?, ?)',
           (datetime.now().isoformat(), name, json.dumps(parameters))
       )
       conn.commit()
       conn.close()
   ```

2. **PostgreSQL Integration** (for production):
   ```python
   import psycopg2
   
   def get_db_connection():
       conn = psycopg2.connect(
           host='localhost',
           database='simulation_db',
           user='postgres',
           password='password'
       )
       return conn
   
   def save_simulation_data(simulation_id, data_df):
       conn = get_db_connection()
       cursor = conn.cursor()
       
       # Convert DataFrame to records
       records = data_df.to_records(index=False)
       
       # Use execute_values for efficient insertion
       from psycopg2.extras import execute_values
       execute_values(
           cursor,
           "INSERT INTO simulation_data (simulation_id, time, civilization_count, knowledge_mean) VALUES %s",
           [(simulation_id, record[0], record[1], record[2]) for record in records]
       )
       
       conn.commit()
       conn.close()
   ```

### Real-time Updates

To enable real-time dashboard updates:

1. **Server-Sent Events (SSE)**:
   ```python
   @app.route('/api/sse')
   def sse():
       def event_stream():
           while True:
               # Check for new data
               if has_new_data():
                   data = get_latest_data()
                   yield f"data: {json.dumps(data)}\n\n"
               time.sleep(1)
       
       return Response(event_stream(), mimetype="text/event-stream")
   ```

2. **Client-side SSE handling**:
   ```javascript
   const eventSource = new EventSource('/api/sse');
   
   eventSource.onmessage = function(event) {
       const newData = JSON.parse(event.data);
       updateDashboardWithNewData(newData);
   };
   
   eventSource.onerror = function() {
       console.error('SSE connection error');
       eventSource.close();
   };
   ```

### Authentication System

To add user authentication:

1. **Flask-Login Integration**:
   ```python
   from flask_login import LoginManager, UserMixin, login_required, login_user, logout_user
   
   login_manager = LoginManager()
   login_manager.init_app(app)
   
   class User(UserMixin):
       def __init__(self, id):
           self.id = id
           
   @login_manager.user_loader
   def load_user(user_id):
       return User(user_id)
   
   @app.route('/login', methods=['GET', 'POST'])
   def login():
       if request.method == 'POST':
           username = request.form['username']
           password = request.form['password']
           
           # Validate credentials
           if username == 'admin' and password == 'secure-password':
               user = User(username)
               login_user(user)
               return redirect(url_for('index'))
           
       return render_template('login.html')
   
   @app.route('/dashboard')
   @login_required
   def protected_dashboard():
       return render_template('dashboard.html')
   ```

2. **Login Template**:
   ```html
   <!-- templates/login.html -->
   <form method="post">
       <input type="text" name="username" placeholder="Username">
       <input type="password" name="password" placeholder="Password">
       <button type="submit">Login</button>
   </form>
   ```

### Data Export Features

To enable data export:

1. **CSV Export Endpoint**:
   ```python
   @app.route('/api/export/csv')
   def export_csv():
       try:
           # Load simulation data
           df = pd.read_csv(data_dir / "multi_civilization_statistics.csv")
           
           # Create a CSV string
           csv_data = df.to_csv(index=False)
           
           # Return as a downloadable file
           response = make_response(csv_data)
           response.headers["Content-Disposition"] = "attachment; filename=simulation_data.csv"
           response.headers["Content-Type"] = "text/csv"
           return response
       except Exception as e:
           return jsonify({"error": str(e)}), 500
   ```

2. **Export Button in UI**:
   ```html
   <button id="export-csv" class="btn btn-primary">Export to CSV</button>
   ```

3. **JavaScript Handler**:
   ```javascript
   document.getElementById('export-csv').addEventListener('click', () => {
       window.location.href = '/api/export/csv';
   });
   ```

## Troubleshooting

### Common Issues

#### Dashboard Shows No Data

**Possible causes**:
- CSV files don't exist in the expected location
- CSV files have incorrect format or column names
- API endpoints returning errors

**Solutions**:
- Check console for error messages
- Verify CSV files exist in the data directory
- Validate CSV format with a tool like pandas

#### Charts Not Rendering

**Possible causes**:
- JavaScript errors
- Chart.js library not loading
- Data format incompatible with chart configuration

**Solutions**:
- Check browser console for JavaScript errors
- Verify Chart.js is properly loaded in the network tab
- Test with simplified data to isolate the issue

#### Performance Issues

**Possible causes**:
- Too much data being loaded at once
- Inefficient chart rendering
- Browser memory limitations

**Solutions**:
- Implement data downsampling for large datasets
- Limit the number of visible charts at once
- Add pagination for large datasets

#### API Endpoint Errors

**Possible causes**:
- File not found exceptions
- Data processing errors
- Memory limitations

**Solutions**:
- Add more detailed error logging
- Implement proper exception handling
- Add data validation before processing

### Debugging

For detailed debugging:

1. **Enable Flask Debug Mode**:
   ```python
   app.run(debug=True)
   ```

2. **Add Detailed Logging**:
   ```python
   import logging
   
   logging.basicConfig(
       level=logging.DEBUG,
       format='%(asctime)s %(levelname)s: %(message)s',
       handlers=[
           logging.FileHandler('dashboard.log'),
           logging.StreamHandler()
       ]
   )
   ```

3. **Check Browser Console**:
   Open browser developer tools (F12) and check the console tab for JavaScript errors.

4. **API Testing**:
   Test API endpoints directly in the browser or with tools like curl or Postman.

5. **Data Validation**:
   Print sample data to verify format and structure:
   ```python
   @app.route('/api/debug')
   def debug_data():
       try:
           df = pd.read_csv(data_dir / "multi_civilization_statistics.csv")
           return jsonify({
               "columns": df.columns.tolist(),
               "sample": df.head(5).to_dict('records'),
               "info": {
                   "shape": df.shape,
                   "dtypes": {col: str(dtype) for col, dtype in df.dtypes.items()}
               }
           })
       except Exception as e:
           return jsonify({"error": str(e)}), 500
   ```